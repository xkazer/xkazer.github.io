<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
  <link href="../css/prism.css" rel="stylesheet" />
  <link rel="stylesheet" type="text/css" href="../css/skeleton.css">
  <link rel="stylesheet" type="text/css" href="../css/common.css">
  <link rel="stylesheet" type="text/css" href="../css/markdown.css">
  <title>xkazer</title>
</head>
<body>
  <div class="app">
    <header>
      <nav>
        <ul>
          <li><a href="#">关于</a></li>
          <li><a href="../doc/note.html">笔记</a></li>
          <li><a href="../doc/study.html">学习</a></li>
          <li><a href="../home.html">导航</a></li>
        </ul>
        <div class="title"><a href="../index.html">kazer</a></div>
      </nav>
    </header>
    <div class="markdown">
      <h4>盒子模型(box-sizing)</h4>
<ul>
<li>W3C标准盒子模型(content-box): 属性width，height只包含content，不包含border和padding</li>
<li>IE盒子模型(border-box): 属性width，height包含content、border和padding</li>
</ul>
<h4>CSS选择符</h4>
<ul>
<li>id选择器(#myid)</li>
<li>类选择器(.myclassname)</li>
<li>标签选择器(div,h1,p)</li>
<li>后代选择器(h1 p)</li>
<li>相邻后代选择器(子)选择器(ul&gt;li)</li>
<li>兄弟选择器(li~a)</li>
<li>相邻兄弟选择器(li+a)</li>
<li>属性选择器(a[rel=&quot;external&quot;])</li>
<li>伪类选择器(a:hover,li:nth-child)</li>
<li>伪元素选择器(::before, ::after)</li>
<li>通配符选择器(*)</li>
</ul>
<h4>伪类和伪元素</h4>
<p>伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如悬停</p>
<p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如::before在元素前增加文本</p>
<p>注: 由于旧版本中的W3C规范并未对此进行特别区分，所以绝大多数浏览器都支持(::)和(:)两个方式表示伪元素。</p>
<h4>CSS哪些属性可以继承</h4>
<ul>
<li>字体系列属性: font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust</li>
<li>文本系列属性: text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、text-transform、direction、color</li>
<li>表格布局属性: caption-side、border-collapse、empty-cells</li>
<li>列表属性: list-style-type、list-style-image、list-style-position、list-style</li>
<li>光标属性: cusor</li>
<li>元素可见性: visibility</li>
<li>其他: speak、page等</li>
</ul>
<p>注: 当一个属性不是继承属性时，可以使用inherit关键字指定一个属性应从父元素继承它的值，inherit关键字用于显示地指定继承性，可用于任何继承性/非继承性属性。</p>
<h4>CSS优先级算法</h4>
<p>选择器特殊性分四个等级:</p>
<ul>
<li>标签内选择符  x,0,0,0</li>
</ul>
<pre><code>&lt;span style=&quot;color:red;&quot;&gt;
</code></pre>
<ul>
<li>ID选择符     0,x,0,0</li>
</ul>
<pre><code>#text{color:red;}
</code></pre>
<ul>
<li>class选择符/属性选择符/伪类选择符 0,0,x,0</li>
</ul>
<pre><code>.text{color:red;} [type=&quot;text&quot;]{color:red}
</code></pre>
<ul>
<li>元素和伪元素选择符     0,0,0,x</li>
</ul>
<pre><code>span{color:red;}
</code></pre>
<p>特点:</p>
<ul>
<li>每个等级初始值为0</li>
<li>每个等级的叠加为选择器出现的次数相加</li>
<li>不可进位</li>
<li>等级从左向右，如果某一位相同，则判断下一位</li>
<li>优化级相同，则最后出现的优化级高，!important也适用</li>
<li>通配符选择器特殊性为: 0,0,0,0</li>
<li>继承样式优化级最低，通配符样式优先级高于继承样式</li>
</ul>
<h4>关于伪类LVHA的解释</h4>
<p>a标签有四种状态: 链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类: :link、:visited、:hover、:active</p>
<p>链接访问前:</p>
<ul>
<li>当鼠标滑过a标签时，满足:link和:hover两个状态，:hover伪类须在:link伪类后面声明</li>
<li>当鼠标点击激活a标签时，同时满足:link、:hover、:active三种状态，必须将:active声明放到:link和:hover后，因此得出LVHA顺序</li>
</ul>
<h4>position的值relative和absolute定位原点</h4>
<ul>
<li>absolute: 绝对定位，相对于值不为static(absolute或relative)的第一个父元素的padding box进行定位</li>
<li>fixed: 绝对定位，相对于浏览器窗口进行定位</li>
<li>relative: 相对定位，相对于其元素本身所在正常位置进行定位</li>
<li>static: 默认值，没有定位</li>
<li>inherit: 从父元素继承position属性</li>
</ul>
<h4>display、position和float的相互关系</h4>
<ul>
<li>display为none时，position和float值不影响表现</li>
<li>position为absolute或fixed时，float属性失败，且display会被设置为table或block</li>
<li>position不为absolute或fixed，则判断float是否为none，不是则正常转换display</li>
<li>如果float为none，则判断元素是否根元素，是则正常转换，否则保持display属性不变</li>
</ul>
<h4>CSS优化、提供性能的方法:</h4>
<p>加载性能:</p>
<ul>
<li>css压缩:将写好的css进行打包压缩，可以减少很多的体积</li>
<li>css单一样式： 当需要下边距和左边距时，很多时候选择(margin: top 0 bottom 0;)但(margin-bottom:bottom;margin-left:left;)执行效率更高</li>
<li>减少使用@import，而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载
选择器性能:</li>
<li>关键选择器: 选择器的最后面部分为关键选择器(即用来匹配目标元素的部分)。CSS选择符是从右到从进行匹配的。当使用后代选择器时，浏览器会遍历所有子元素来确定是否是指定的元素等等</li>
<li>如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤无关的规则(这样样式系统就不会浪费时间去匹配它们了)</li>
<li>避免使用通配规则，如*{}计算次数惊人</li>
<li>尽量少的去对标签进行选择，而是用class</li>
<li>尽量少的去使用后代选择器，降低选择器的权重值。后代选择器是开销最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素</li>
<li>了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则
渲染性能:</li>
<li>慎重使用高性能属性: 浮动、定位</li>
<li>尽量减少页面重排、重绘</li>
<li>去除空规则: {}</li>
<li>属性值为0时，不加单位</li>
<li>属性值为浮点小数0.**，可以省略小数点之前的0</li>
<li>标准化各种浏览器前缀: 带浏览器前缀的在前。标准属性在后</li>
<li>不使用@import前缀</li>
<li>选择器优化嵌套，避免层级过深</li>
<li>CSS雪碧图，减少页面的请求次数</li>
<li>正确使用display属性，由于display的作用，某些样式组合会失效，徒增样式体积也影响解析性能</li>
<li>不滥用web字体。
可维护性、健壮性:</li>
<li>将相同属性的样式抽离出来，整合并通过class在页面中使用，提高页面可维护性</li>
<li>样式和内容分离: 将css代码定义到外部css中</li>
</ul>
<h4>flex</h4>
<p>重要概念:</p>
<ul>
<li>flex容器: 设置 display: flex; 的元素</li>
<li>flex项目: flex容器内的元素</li>
<li>主轴: 项目排列方向</li>
<li>交叉轴</li>
</ul>
<p>flex容器的属性:</p>
<ul>
<li>flex-direction: 设置主轴方向, 值: <strong>row</strong>、row-reverse、column、column-reverse</li>
<li>flex-wrap: 设置容器内项目是否可换行，值: <strong>nowrap</strong>、wrap、wrap-reverse</li>
<li>flex-flow: 上面两个的合体，默认值 : <strong>row nowrap</strong></li>
<li>justify-content: 主轴对齐方式，值: <strong>flex-start</strong>、flex-end、center、space-between、space-around</li>
<li>align-items: 交叉轴上的对齐方式，值: <strong>stretch</strong>(若无高度则占满整个高度)、flex-start、flex-end、center、baseline(第一行文本基线对齐)</li>
<li>align-content: 多根轴线的对齐方式, 值: <strong>stretch</strong>(平分空间，且未设置高度是撑满)、flex-start、flex-end、center、space-betweeen、space-around</li>
</ul>
<p>flex项目属性</p>
<ul>
<li>flex-grow: 定义项目的放大比例，默认值为0，即如果有剩余空间，也不放大</li>
<li>flex-shrink: 定义项目的缩小比例，默认值为1，即空间不足，该项目将缩小</li>
<li>flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余的空间。值: <strong>auto</strong>(即项目本来的大小)</li>
<li>order: 定义项目在容器中的排列顺序，数值越小，排列越靠前，默认为0</li>
<li>align-self: 允许单个项目与其他项目不一样的对齐方式。值: <strong>auto</strong>(即继承父元素的align-items属性)、flex-start、flex-end、center、baseline、stretch</li>
</ul>
<h4>grid</h4>
<p>二维布局方式，相对于使用HTML结构实现的table布局, grid布局都是在CSS中完成的</p>
<p>重要概念:</p>
<ul>
<li>grid容器</li>
<li>grid项目</li>
<li>行</li>
<li>列</li>
<li>单元格</li>
<li>网络线</li>
</ul>
<p>grid容器的属性</p>
<ul>
<li>grid-template-columns</li>
<li>grid-template-rows</li>
<li>gap(column-gap、row-gap)</li>
<li>place-items(justify-items、align-items)</li>
<li>place-content(justify-content、align-content)</li>
<li>grid-template-areas</li>
<li>grid-auto-flow</li>
<li>grid-auto-columns、grid-auto-rows</li>
</ul>
<p>grid项目的属性:</p>
<ul>
<li>grid-column-start、grid-column-end</li>
<li>grid-row-start、grid-row-end</li>
<li>grid-column</li>
<li>grid-row</li>
<li>grid-area</li>
<li>justify-self、align-self</li>
<li>place-self</li>
</ul>

    </div>
  </div>
  <script src="../js/prism.js"></script>
</body>
</html>