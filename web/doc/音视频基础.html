<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
  <link href="../css/prism.css" rel="stylesheet" />
  <link rel="stylesheet" type="text/css" href="../css/skeleton.css">
  <link rel="stylesheet" type="text/css" href="../css/common.css">
  <link rel="stylesheet" type="text/css" href="../css/markdown.css">
  <title>xkazer</title>
</head>
<body>
  <div class="app">
    <header>
      <nav>
        <ul>
          <li><a href="#">关于</a></li>
          <li><a href="../doc/note.html">笔记</a></li>
          <li><a href="../doc/study.html">学习</a></li>
          <li><a href="../home.html">导航</a></li>
        </ul>
        <div class="title"><a href="../index.html">kazer</a></div>
      </nav>
    </header>
    <div class="markdown">
      <h4>视频传输原理</h4>
<blockquote>
<p>视频是利用人眼视觉暂留的原理，通过播放一系列的图片，使人眼产生运动的感觉。单纯传输视频画面，数据量太大，因此有了H.264视频压缩标准。
视频里面的原始图像数据会采用H.264编码格式进行压缩，音频采样数据会采用AAC编码格式进行压缩。</p>
</blockquote>
<h5>I帧</h5>
<blockquote>
<p>Intra-coded picture(帧内编码图像帧), I帧表示关键帧，解码时只需要本帧数据就可以完成。编码流程:</p>
</blockquote>
<ul>
<li>进行帧内预测，决定所采用的帧内预测模式</li>
<li>像素值减去预测值，得到残差</li>
<li>对残差进行变换和量化</li>
<li>变长编码和算术编码</li>
<li>重构图像并滤波，得到的图像作为其他帧的参考帧</li>
</ul>
<h5>P帧</h5>
<blockquote>
<p>Predictive-coded Picture(前向预测编码图像帧), P帧表示的是这一帧和之前的一个关键帧(或P帧)的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。特点:</p>
</blockquote>
<ul>
<li>P帧是I帧后面相隔1~2帧的编码帧</li>
<li>P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差)</li>
<li>解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧</li>
<li>P帧属于前向预测的的帧间编码。它只参考前面的最靠近它的I帧或P帧</li>
<li>由于P帧是参考帧，它可能造成编码错误的扩散</li>
<li>由于是差值传送，P帧的压缩比较高</li>
</ul>
<h5>B帧</h5>
<blockquote>
<p>Bidirectionally predicted picture(双向预测编码图像帧), B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别，换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面与本帧数据的叠加取得最终的画面。
B帧压缩率高，但是解码时CPU会比较累。特点:</p>
</blockquote>
<ul>
<li>B帧是由前面的I或P帧和后面的P帧来进行预测的</li>
<li>B帧传送的是它与前面的I帧或P帧和后面的P帧之间的预测误差及运动矢量</li>
<li>B帧是双向预测编码帧</li>
<li>B帧压缩比最高，因为它只反映丙参考帧间运动主体的变化情况，预测比较准确</li>
<li>B帧不是参考帧，不会造成解码错误的扩散</li>
</ul>
<h5>GOP(序列)和IDR</h5>
<blockquote>
<p>在H264中图像以<strong>序列</strong>为单位进行组织，一个序列是一段图像编码后的数据流
一个序列的第一个图像叫做<strong>IDR图像(立即刷新图像)</strong>，IDR图像都是I帧图像。H.264引入IDR图像是为了解码的重同步，当解码器解码到IDR图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。
在视频编码序列中，GOP即Group of picture(<strong>图像组</strong>),指两个I帧之前的距离，Reference(<strong>参考周期</strong>)指两个P帧之间的距离。两个I帧之间形成一组图片，就是GOP。</p>
</blockquote>
<p><img src="http://pc-cors.elitb.com/proxy?url=https://img2020.cnblogs.com/blog/653161/202112/653161-20211216165707365-1947946625.png" alt=""></p>
<h5>PTS和DTS</h5>
<blockquote>
<p>P帧需要参考前面的I帧或P帧，B帧需要参考前面的I帧和P帧及后面的P帧。这就给解码带来了问题: 先到来的B帧无法立即解码，需要等待它依赖的后面的I、P帧先解码完成，这样一来播放时间与解码时间就不一致了。</p>
</blockquote>
<ul>
<li>DTS(Decoding Time Stamp): <strong>解码时间戳</strong>, 这个时间戳的意义在于告诉播放器该在什么时候解码这一帧的数据。</li>
<li>PTS(Presentation Time Stamp): <strong>显示时间戳</strong>, 这个时间戳用来告诉播放器该在什么时候显示这一帧的数据。</li>
</ul>
<blockquote>
<p>虽然DTS、PTS是用于指导播放端的行为，但它是在编码时由编码器生成的。例:</p>
</blockquote>
<pre><code class="language-javascript">I B B P B B P
1 2 3 4 5 6 7       // 显示顺序
1 4 2 3 7 5 6       // 编码顺序

I P B B P B B       // 网络推流顺序
1 2 3 4 5 6 7       // 解码顺序 (DTS)
1 4 2 3 7 5 6       // 播放顺序 (PTS)
// 按PTS重新调整解码后的frame(帧)
I B B P B B P
1 3 4 2 6 7 5     // DTS
1 2 3 4 5 6 7     // PTS
</code></pre>

    </div>
  </div>
  <script src="../js/prism.js"></script>
</body>
</html>